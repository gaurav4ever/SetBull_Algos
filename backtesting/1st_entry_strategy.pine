//@version=5
// Limit strategy to consider only data from the last 27 days
strategy("MR First Entry Backtester", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100, initial_capital=100000, max_bars_back=2000, max_labels_count=500)

// =======================================================================
// Configuration Parameters
// =======================================================================
var string rangeType = input.string("5MR", "Morning Range Type", options=["5MR", "15MR"])
var bool respectTrend = input.bool(true, "Respect Trend (Buy above 50EMA, Sell below 50EMA)")
var float stopLossPercent = input.float(0.5, "Stop Loss (% of entry price)", minval=0.1, step=0.1)
var float tp1RR = input.float(3.0, "First Take Profit (R:R)", minval=1.0, step=0.5)
var float tp2RR = input.float(5.0, "Second Take Profit (R:R)", minval=1.0, step=0.5)
var float tp3RR = input.float(7.0, "Third Take Profit (R:R)", minval=1.0, step=0.5)

var float tp1Size = input.float(10.0, "First Take Profit Size (%)", minval=5.0, step=5.0)
var float tp2Size = input.float(40.0, "Second Take Profit Size (%)", minval=5.0, step=5.0)
// Third TP size is calculated as (100 - tp1Size - tp2Size)

// New input for tick size
// Exact entry -> Above/below 5MR range
var float tickSize = input.float(0.05, "Tick Size", minval=0.01, step=0.01)
var int tickBuffer = input.int(5, "Entry Buffer in Ticks", minval=1, step=1)

var bool enableVisualLabels = input.bool(true, "Show Entry/Exit Labels")
var bool enableTradeLabels = input.bool(true, "Show Trade Stats Labels")
var bool enableLogs = input.bool(true, "Enable Debug Logs")
var color longColor = input.color(color.green, "Long Color")
var color shortColor = input.color(color.red, "Short Color")

// ATR for dynamic sizing
var int atrLength = input.int(14, "ATR Length", minval=1)
var float atrToMRRatioThreshold = input.float(3.0, "ATR/MR Ratio Threshold", minval=1.0, step=0.5)
var int emaLength = input.int(50, "EMA Length for Trend", minval=5)
var int lookbackPeriod = input.int(27, "Lookback Period (Days)", minval=1)

// Maximum number of bars to analyze (27 days worth of 5-min bars)
var int maxLookbackBars = 27 * 75  // Approximate 5-min bars in 27 trading days

// =======================================================================
// Time and Session Definitions
// =======================================================================
is_5min_timeframe = timeframe.period == "5"
if not is_5min_timeframe
    runtime.error("This script requires 5-minute timeframe")

// Time-based session definitions
// TODO: Add strategy trading hours also so that I can define which strategy works in which hours. 
isTradingHours = (time >= timestamp(year, month, dayofmonth, 9, 15, 0)) and (time <= timestamp(year, month, dayofmonth, 15, 30, 0))

is5MRPeriod = (time >= timestamp(year, month, dayofmonth, 9, 15, 0)) and (time < timestamp(year, month, dayofmonth, 9, 20, 0))

is15MRPeriod = (time >= timestamp(year, month, dayofmonth, 9, 15, 0)) and (time < timestamp(year, month, dayofmonth, 9, 30, 0))

// VERY IMPORTANT
// This is where I'm defining the exact 9:20AM trade time.
isEntryAllowed = (rangeType == "5MR") ? (time >= timestamp(year, month, dayofmonth, 9, 20, 0)) : (time >= timestamp(year, month, dayofmonth, 9, 30, 0))

isLastCandleOfDay = (time >= timestamp(year, month, dayofmonth, 15, 25, 0)) and (time < timestamp(year, month, dayofmonth, 15, 30, 0))

isNewTradingDay = ta.change(dayofmonth) != 0 or (na(dayofmonth[1]) and not na(dayofmonth))

// =======================================================================
// State Tracking Variables
// =======================================================================
// EMA and Trend determination
var float ema50 = ta.ema(close, emaLength)
var bool isAboveEMA = close > ema50
var string currentTrend = isAboveEMA ? "BULLISH" : "BEARISH"

// Morning Range levels
var float mrHigh = 0.0
var float mrLow = 0.0
var float mrSize = 0.0
var float atr = ta.atr(atrLength)[1]  // Using previous day's ATR

// Entry price with 5-tick buffer
var float longEntryPrice = 0.0
var float shortEntryPrice = 0.0

// Trade management
var float entryPrice = 0.0
var float stopPrice = 0.0
var float tp1Price = 0.0
var float tp2Price = 0.0
var float tp3Price = 0.0
var float riskAmount = 0.0
var float tp1_pnl = 0.0
var float tp2_pnl = 0.0
var float tp3_pnl = 0.0
var bool inLongTrade = false
var bool inShortTrade = false
var bool hitBreakeven = false
var bool hitTp1 = false
var bool hitTp2 = false
var bool mrCalculated = false
var bool mrRangeValid = false

// New variable to track if we've already traded today
var bool tradedToday = false

// Logging
var string lastLogMessage = ""

// Performance tracking - cumulative
var int tradeDays = 0
var int executedDays = 0
var int profitDays = 0 
var int lossDays = 0
var float totalProfit = 0.0
var float totalLoss = 0.0
var int consecutiveWins = 0
var int consecutiveLosses = 0
var int maxConsecutiveWins = 0
var int maxConsecutiveLosses = 0
var int longTrades = 0
var int shortTrades = 0
var int longWins = 0
var int longLosses = 0
var int shortWins = 0
var int shortLosses = 0

// Daily tracking
var float todayPnL = 0.0
var bool dayWon = false
var bool dayLost = false

// =======================================================================
// Helper Functions
// =======================================================================
logDebug(message) =>
    if enableLogs
        label.new(bar_index, high, message, color=color.gray, textcolor=color.white, style=label.style_label_down, size=size.small)
    message

// =======================================================================
// Trend Determination
// =======================================================================
// Calculate 50 EMA
ema50 := ta.ema(close, emaLength)
isAboveEMA := close > ema50
currentTrend := isAboveEMA ? "BULLISH" : "BEARISH"

// Update ATR daily
// LOGIC: As soon as 9:15AM passes. The very next MINUTE. 9:16AM candle, calcaulate ATR of previous 
// day to calculate MR range
if is5MRPeriod and time >= timestamp(year, month, dayofmonth, 9, 15, 0) and time < timestamp(year, month, dayofmonth, 9, 16, 0)
    atr := ta.atr(atrLength)[1]  // Get previous day's ATR at the start of each day

// Plot EMA
plot(ema50, "50 EMA", color=color.blue, linewidth=1)

// =======================================================================
// Morning Range Calculation
// =======================================================================
// Reset MR values and trade status on new trading day
if isNewTradingDay
    mrHigh := 0.0
    mrLow := 0.0
    mrSize := 0.0
    mrCalculated := false
    mrRangeValid := false
    // Reset the tradedToday flag to allow new trades
    tradedToday := false
    lastLogMessage := logDebug("New Day - Reset MR values and trade status")

// Calculate 5MR
if rangeType == "5MR" and is5MRPeriod
    if not mrCalculated
        // Record high/low for the first 5 min candle
        mrHigh := high
        mrLow := low
        mrSize := mrHigh - mrLow
        
        // Calculate entry prices with 5-tick buffer
        longEntryPrice := mrHigh + (tickSize * tickBuffer)
        shortEntryPrice := mrLow - (tickSize * tickBuffer)
        
        float atrToMRRatio = mrSize > 0 ? atr / mrSize : 0
        mrRangeValid := atrToMRRatio > atrToMRRatioThreshold // this is where I decide to Trade MR trades
        mrCalculated := true
        
        if enableLogs
            logDebug("5MR Calculated - High: " + str.tostring(mrHigh) + " Low: " + str.tostring(mrLow) + " Size: " + str.tostring(mrSize) + " Long Entry: " + str.tostring(longEntryPrice) + " Short Entry: " + str.tostring(shortEntryPrice) + " Valid: " + (mrRangeValid ? "Yes" : "No"))

// Calculate 15MR
if rangeType == "15MR" and is15MRPeriod
    // Update high/low during the 15 min period
    if mrHigh == 0.0 or high > mrHigh
        mrHigh := high
    if mrLow == 0.0 or low < mrLow
        mrLow := low
    
    // Finalize MR at the end of 15MR period
    if time >= timestamp(year, month, dayofmonth, 9, 29, 55)
        mrSize := mrHigh - mrLow
        
        // Calculate entry prices with 5-tick buffer
        longEntryPrice := mrHigh + (tickSize * tickBuffer)
        shortEntryPrice := mrLow - (tickSize * tickBuffer)
        
        // Calculate ATR to MR ratio instead of using threshold
        float atrToMRRatio = mrSize > 0 ? atr / mrSize : 0
        mrRangeValid := atrToMRRatio > atrToMRRatioThreshold
        mrCalculated := true
        
        if enableLogs
            lastLogMessage := logDebug("15MR Calculated - High: " + str.tostring(mrHigh) + 
                           " Low: " + str.tostring(mrLow) + 
                           " Size: " + str.tostring(mrSize) + 
                           " Long Entry: " + str.tostring(longEntryPrice) + 
                           " Short Entry: " + str.tostring(shortEntryPrice) + 
                           " ATR/MR Ratio: " + str.tostring(atrToMRRatio) + 
                           " Valid: " + (mrRangeValid ? "Yes" : "No"))

// Plot MR levels if calculated
if mrCalculated
    var line mrhighLine = na
    var line mrlowLine = na
    var line longEntryLine = na
    var line shortEntryLine = na
    
    if barstate.isfirst or ta.change(dayofmonth) != 0
        mrhighLine := line.new(bar_index, mrHigh, bar_index, mrHigh, color=color.green, width=2)
        mrlowLine := line.new(bar_index, mrLow, bar_index, mrLow, color=color.red, width=2)
        longEntryLine := line.new(bar_index, longEntryPrice, bar_index, longEntryPrice, color=color.green, width=1, style=line.style_dashed)
        shortEntryLine := line.new(bar_index, shortEntryPrice, bar_index, shortEntryPrice, color=color.red, width=1, style=line.style_dashed)
    else
        line.set_x2(mrhighLine, bar_index)
        line.set_x2(mrlowLine, bar_index)
        line.set_y1(mrhighLine, mrHigh)
        line.set_y2(mrhighLine, mrHigh)
        line.set_y1(mrlowLine, mrLow)
        line.set_y2(mrlowLine, mrLow)
        line.set_x2(longEntryLine, bar_index)
        line.set_x2(shortEntryLine, bar_index)
        line.set_y1(longEntryLine, longEntryPrice)
        line.set_y2(longEntryLine, longEntryPrice)
        line.set_y1(shortEntryLine, shortEntryPrice)
        line.set_y2(shortEntryLine, shortEntryPrice)

// =======================================================================
// First Entry Strategy Logic - MODIFIED FOR SINGLE ENTRY PER DAY
// =======================================================================
// Check if we're within the lookback period
var startBarIndex = 0
if bar_index == 0
    startBarIndex := bar_index
var int barsFromStart = bar_index - startBarIndex
var bool isWithinLookbackPeriod = barsFromStart <= maxLookbackBars

// Only process trades if within lookback period
if isWithinLookbackPeriod
    // Check for entry conditions - only if we haven't traded today
    if isEntryAllowed and mrRangeValid and not inLongTrade and not inShortTrade and mrCalculated and not tradedToday and barstate.isconfirmed
        // Long entry when price reaches the buffered entry price (5 ticks above MR high)
        if high >= longEntryPrice and (not respectTrend or isAboveEMA)
            entryPrice := longEntryPrice  // Using the buffered entry price
            stopPrice := entryPrice * (1 - stopLossPercent/100)
            riskAmount := entryPrice - stopPrice
            
            tp1Price := entryPrice + (riskAmount * tp1RR)
            tp2Price := entryPrice + (riskAmount * tp2RR)
            tp3Price := entryPrice + (riskAmount * tp3RR)
            
            strategy.entry("First_Long", strategy.long, limit=longEntryPrice)
            inLongTrade := true
            tradedToday := true  // Mark that we've traded today
            longTrades := longTrades + 1
            
            // Add blue label to mark the breakout candle
            label.new(bar_index, high * 1.01, "BREAKOUT", color=color.blue, style=label.style_label_down, textcolor=color.white, size=size.normal)
            
            if enableLogs
                lastLogMessage := logDebug("LONG ENTRY - Price: " + str.tostring(entryPrice) + " Stop: " + str.tostring(stopPrice) + " TP1: " + str.tostring(tp1Price) + " TP2: " + str.tostring(tp2Price) + " TP3: " + str.tostring(tp3Price))
            
            // Visual entry marker
            if enableVisualLabels
                label.new(bar_index, low * 0.999, "LONG\nEntry: " + str.tostring(entryPrice, "#.##") + 
                         "\nStop: " + str.tostring(stopPrice, "#.##"), 
                         color=longColor, style=label.style_label_up, textcolor=color.white)
        
        // Short entry when price reaches the buffered entry price (5 ticks below MR low)
        else if low <= shortEntryPrice and (not respectTrend or not isAboveEMA)
            entryPrice := shortEntryPrice  // Using the buffered entry price
            stopPrice := entryPrice * (1 + stopLossPercent/100)
            riskAmount := stopPrice - entryPrice
            
            tp1Price := entryPrice - (riskAmount * tp1RR)
            tp2Price := entryPrice - (riskAmount * tp2RR)
            tp3Price := entryPrice - (riskAmount * tp3RR)
            
            strategy.entry("First_Short", strategy.short, limit=shortEntryPrice)
            inShortTrade := true
            tradedToday := true  // Mark that we've traded today
            shortTrades := shortTrades + 1
            
            // Add blue label to mark the breakout candle
            label.new(bar_index, low * 0.99, "BREAKOUT", color=color.blue, style=label.style_label_up, textcolor=color.white, size=size.normal)
            
            if enableLogs
                lastLogMessage := logDebug("SHORT ENTRY - Price: " + str.tostring(entryPrice) + 
                         " Stop: " + str.tostring(stopPrice) + 
                         " TP1: " + str.tostring(tp1Price) + 
                         " TP2: " + str.tostring(tp2Price) + 
                         " TP3: " + str.tostring(tp3Price))
            
            // Visual entry marker
            if enableVisualLabels
                label.new(bar_index, high * 1.001, "SHORT\nEntry: " + str.tostring(entryPrice, "#.##") + 
                         "\nStop: " + str.tostring(stopPrice, "#.##"), 
                         color=shortColor, style=label.style_label_down, textcolor=color.white)
        else if mrCalculated and isEntryAllowed and mrRangeValid and enableLogs
            if high > mrHigh and respectTrend and not isAboveEMA
                lastLogMessage := logDebug("LONG SKIPPED - Below EMA50, Current trend: " + currentTrend)
            else if low < mrLow and respectTrend and isAboveEMA
                lastLogMessage := logDebug("SHORT SKIPPED - Above EMA50, Current trend: " + currentTrend)
    
    // Log if we've already traded today
    else if isEntryAllowed and mrRangeValid and not inLongTrade and not inShortTrade and mrCalculated and tradedToday and enableLogs
        if (high >= longEntryPrice and (not respectTrend or isAboveEMA)) or (low <= shortEntryPrice and (not respectTrend or not isAboveEMA))
            lastLogMessage := logDebug("ENTRY SKIPPED - Already traded today")

// =======================================================================
// Trade Management Logic
// =======================================================================
// Long trade management
if inLongTrade
    // Stop loss hit
    if low <= stopPrice and not hitBreakeven
        strategy.close("First_Long", comment="SL")
        inLongTrade := false
        todayPnL := -riskAmount / entryPrice * 100  // Convert to percentage
        dayLost := true
        longLosses := longLosses + 1
        
        if enableLogs
            lastLogMessage := logDebug("LONG STOPPED OUT - Loss: " + str.tostring(todayPnL) + "%")
        
        if enableVisualLabels
            label.new(bar_index, low * 0.999, "SL", color=color.red, style=label.style_label_up, textcolor=color.white)
    
    // Move to breakeven after price reaches 1:1 R:R
    if high >= entryPrice + riskAmount and not hitBreakeven
        stopPrice := entryPrice
        hitBreakeven := true
        
        if enableLogs
            lastLogMessage := logDebug("LONG MOVED TO BREAKEVEN")
        
        if enableVisualLabels
            label.new(bar_index, low * 0.999, "BE", color=color.blue, style=label.style_label_up, textcolor=color.white)
    
    // Take profit 1 (10%)
    if high >= tp1Price and not hitTp1
        strategy.order("TP1_Long", strategy.long, qty=math.abs((strategy.position_size * tp1Size / 100)), limit=tp1Price)
        hitTp1 := true
        
        if enableLogs
            lastLogMessage := logDebug("LONG TP1 HIT - " + str.tostring(tp1Size) + "% of position")
        
        if enableVisualLabels
            label.new(bar_index, high * 1.001, "TP1", color=color.green, style=label.style_label_down, textcolor=color.white)
    
    // Take profit 2 (40%)
    if high >= tp2Price and not hitTp2
        strategy.order("TP2_Long", strategy.long, qty=math.abs((strategy.position_size * tp2Size / 100)), limit=tp2Price)
        hitTp2 := true
        
        // Move stop after TP2 to lock in more profit
        stopPrice := entryPrice + (tp1Price - entryPrice) * 0.5
        
        if enableLogs
            lastLogMessage := logDebug("LONG TP2 HIT - " + str.tostring(tp2Size) + "% of position, Trail SL to " + str.tostring(stopPrice))
        
        if enableVisualLabels
            label.new(bar_index, high * 1.001, "TP2", color=color.green, style=label.style_label_down, textcolor=color.white)
    
    // Take profit 3 (remaining 50%)
    if high >= tp3Price
        strategy.close("First_Long", comment="TP3")
        inLongTrade := false
        
        // Calculate the blended P&L
        float remaining_size = 100 - tp1Size - tp2Size
        tp1_pnl := tp1Size/100 * (tp1Price - entryPrice)
        tp2_pnl := tp2Size/100 * (tp2Price - entryPrice)
        tp3_pnl := remaining_size/100 * (tp3Price - entryPrice)
        todayPnL := (tp1_pnl + tp2_pnl + tp3_pnl) / entryPrice * 100
        dayWon := true
        longWins := longWins + 1
        
        if enableLogs
            lastLogMessage := logDebug("LONG TP3 HIT - Total profit: " + str.tostring(todayPnL) + "%")
        
        if enableVisualLabels
            label.new(bar_index, high * 1.001, "TP3", color=color.green, style=label.style_label_down, textcolor=color.white)

// Short trade management
if inShortTrade
    // Stop loss hit
    if high >= stopPrice and not hitBreakeven
        strategy.close("First_Short", comment="SL")
        inShortTrade := false
        todayPnL := -riskAmount / entryPrice * 100  // Convert to percentage
        dayLost := true
        shortLosses := shortLosses + 1
        
        if enableLogs
            lastLogMessage := logDebug("SHORT STOPPED OUT - Loss: " + str.tostring(todayPnL) + "%")
        
        if enableVisualLabels
            label.new(bar_index, high * 1.001, "SL", color=color.red, style=label.style_label_down, textcolor=color.white)
    
    // Move to breakeven after price reaches 1:1 R:R
    if low <= entryPrice - riskAmount and not hitBreakeven
        stopPrice := entryPrice
        hitBreakeven := true
        
        if enableLogs
            lastLogMessage := logDebug("SHORT MOVED TO BREAKEVEN")
        
        if enableVisualLabels
            label.new(bar_index, high * 1.001, "BE", color=color.blue, style=label.style_label_down, textcolor=color.white)
    
    // Take profit 1 (10%)
    if low <= tp1Price and not hitTp1
        strategy.order("TP1_Short", strategy.short, qty=math.abs((strategy.position_size * tp1Size / 100)), limit=tp1Price)
        hitTp1 := true
        
        if enableLogs
            lastLogMessage := logDebug("SHORT TP1 HIT - " + str.tostring(tp1Size) + "% of position")
        
        if enableVisualLabels
            label.new(bar_index, low * 0.999, "TP1", color=color.green, style=label.style_label_up, textcolor=color.white)
    
    // Take profit 2 (40%)
    if low <= tp2Price and not hitTp2
        strategy.order("TP2_Short", strategy.short, qty=math.abs((strategy.position_size * tp2Size / 100)), limit=tp2Price)
        hitTp2 := true
        
        // Move stop after TP2 to lock in more profit
        stopPrice := entryPrice - (entryPrice - tp1Price) * 0.5
        
        if enableLogs
            lastLogMessage := logDebug("SHORT TP2 HIT - " + str.tostring(tp2Size) + "% of position, Trail SL to " + str.tostring(stopPrice))
        
        if enableVisualLabels
            label.new(bar_index, low * 0.999, "TP2", color=color.green, style=label.style_label_up, textcolor=color.white)
    
    // Take profit 3 (remaining 50%)
    if low <= tp3Price
        strategy.close("First_Short", comment="TP3")
        inShortTrade := false
        
        // Calculate the blended P&L
        float remaining_size = 100 - tp1Size - tp2Size
        tp1_pnl := tp1Size/100 * (entryPrice - tp1Price)
        tp2_pnl := tp2Size/100 * (entryPrice - tp2Price)
        tp3_pnl := remaining_size/100 * (entryPrice - tp3Price)
        todayPnL := (tp1_pnl + tp2_pnl + tp3_pnl) / entryPrice * 100
        dayWon := true
        shortWins := shortWins + 1
        
        if enableLogs
            lastLogMessage := logDebug("SHORT TP3 HIT - Total profit: " + str.tostring(todayPnL) + "%")
        
        if enableVisualLabels
            label.new(bar_index, low * 0.999, "TP3", color=color.green, style=label.style_label_up, textcolor=color.white)

// =======================================================================
// End of Day Processing
// =======================================================================
if isLastCandleOfDay
    if tradedToday
        executedDays := executedDays + 1
        
        if dayWon
            profitDays := profitDays + 1
            totalProfit := totalProfit + todayPnL
            consecutiveWins := consecutiveWins + 1
            consecutiveLosses := 0
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
            
            if enableLogs
                lastLogMessage := logDebug("DAY STATS: WIN - Profit: " + str.tostring(todayPnL) + "%")
        else if dayLost
            lossDays := lossDays + 1
            totalLoss := totalLoss + todayPnL
            consecutiveLosses := consecutiveLosses + 1
            consecutiveWins := 0
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)
            
            if enableLogs
                lastLogMessage := logDebug("DAY STATS: LOSS - Loss: " + str.tostring(todayPnL) + "%")
        
        // Display daily result
        if enableTradeLabels
            resultColor = dayWon ? color.green : color.red
            resultText = dayWon ? "WIN: +" + str.tostring(math.round(todayPnL * 100) / 100) + "%" : "LOSS: " + str.tostring(math.round(todayPnL * 100) / 100) + "%"
            label.new(bar_index, close, resultText, color=resultColor, textcolor=color.white)
    else if enableLogs
        lastLogMessage := logDebug("DAY STATS: No trade executed today")
    
    tradeDays := tradeDays + 1
    
    // Reset daily variables
    todayPnL := 0.0
    dayWon := false
    dayLost := false
    inLongTrade := false
    inShortTrade := false
    hitBreakeven := false
    hitTp1 := false
    hitTp2 := false
    
    // Reset MR values for next day
    mrHigh := 0.0
    mrLow := 0.0
    mrSize := 0.0
    mrCalculated := false
    mrRangeValid := false
    longEntryPrice := 0.0
    shortEntryPrice := 0.0

// =======================================================================
// Results Calculation & Display
// =======================================================================
if barstate.islast
    // Calculate metrics
    avgProfit = profitDays > 0 ? totalProfit / profitDays : 0
    avgLoss = lossDays > 0 ? totalLoss / lossDays : 0
    winRate = executedDays > 0 ? (profitDays / executedDays) * 100 : 0
    expectancy = (winRate/100 * avgProfit) + ((1 - winRate/100) * avgLoss)
    
    longWinRate = longTrades > 0 ? (longWins / longTrades) * 100 : 0
    shortWinRate = shortTrades > 0 ? (shortWins / shortTrades) * 100 : 0
    
    // Create results table
    var table resultsTable = table.new(position.bottom_right, 2, 14, border_width=1)
    
    // Table header
    table.cell(resultsTable, 0, 0, rangeType + " First Entry Results (Single Entry)", text_color=color.white, bgcolor=color.blue)
    table.cell(resultsTable, 1, 0, "", text_color=color.white, bgcolor=color.blue)
    
    // Statistics rows
    table.cell(resultsTable, 0, 1, "Trading Days:")
    table.cell(resultsTable, 1, 1, str.tostring(tradeDays))
    
    table.cell(resultsTable, 0, 2, "Executed Days:")
    table.cell(resultsTable, 1, 2, str.tostring(executedDays))
    
    table.cell(resultsTable, 0, 3, "Win/Loss Days:")
    table.cell(resultsTable, 1, 3, str.tostring(profitDays) + " / " + str.tostring(lossDays))
    
    table.cell(resultsTable, 0, 4, "Win Rate:")
    winRateColor = winRate >= 50 ? color.green : color.red
    table.cell(resultsTable, 1, 4, str.tostring(math.round(winRate * 100) / 100) + "%", text_color=winRateColor)
    
    table.cell(resultsTable, 0, 5, "Avg Win:")
    table.cell(resultsTable, 1, 5, str.tostring(math.round(avgProfit * 100) / 100) + "%", text_color=color.green)
    
    table.cell(resultsTable, 0, 6, "Avg Loss:")
    table.cell(resultsTable, 1, 6, str.tostring(math.round(avgLoss * 100) / 100) + "%", text_color=color.red)
    
    table.cell(resultsTable, 0, 7, "Expectancy:")
    expColor = expectancy > 0 ? color.green : color.red
    table.cell(resultsTable, 1, 7, str.tostring(math.round(expectancy * 100) / 100) + "%", text_color=expColor)
    
    table.cell(resultsTable, 0, 8, "Long Trades:")
    table.cell(resultsTable, 1, 8, str.tostring(longTrades) + " (" + str.tostring(longWins) + "W/" + str.tostring(longLosses) + "L)")
    
    table.cell(resultsTable, 0, 9, "Long Win Rate:")
    longWinRateColor = longWinRate >= 50 ? color.green : color.red
    table.cell(resultsTable, 1, 9, str.tostring(math.round(longWinRate * 100) / 100) + "%", text_color=longWinRateColor)
    
    table.cell(resultsTable, 0, 10, "Short Trades:")
    table.cell(resultsTable, 1, 10, str.tostring(shortTrades) + " (" + str.tostring(shortWins) + "W/" + str.tostring(shortLosses) + "L)")
    
    table.cell(resultsTable, 0, 11, "Short Win Rate:")
    shortWinRateColor = shortWinRate >= 50 ? color.green : color.red
    table.cell(resultsTable, 1, 11, str.tostring(math.round(shortWinRate * 100) / 100) + "%", text_color=shortWinRateColor)
    
    table.cell(resultsTable, 0, 12, "Max Consec. Wins:")
    table.cell(resultsTable, 1, 12, str.tostring(maxConsecutiveWins))
    
    table.cell(resultsTable, 0, 13, "Max Consec. Losses:")
    table.cell(resultsTable, 1, 13, str.tostring(maxConsecutiveLosses))
    
    if enableLogs
        lastLogMessage := logDebug("CURRENT TREND: " + currentTrend + " (Close: " + str.tostring(close) + " EMA50: " + str.tostring(ema50) + ")")